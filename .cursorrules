# Cursor Rules for Shabangnet

## Tech Stack

- Next.js 16 (App Router)
- React 19
- TypeScript 5
- Tailwind CSS 4
- Drizzle ORM
- TanStack Query
- PostgreSQL 17

## Infrastructure

```
사용자 (Web/PWA/앱)
└─ Cloudflare (cloudflare/terraform/)
   ├─ DNS (dns-records.tf)
   │  ├─ Cloud Run (Next.js Web) (Dockerfile.nextjs, cloudbuild.*.nextjs.yaml)
   │  ├─ Cloud Run (Hono API) (Dockerfile.hono, cloudbuild.*.hono.yaml)
   │  ├─ Vercel (Next.js Edge API) (vercel/)
   │  ├─ Render (Next.js Web) (render.yaml)
   │  ├─ Cloudflare R2 (public.r2.dev)
   │  └─ Cloudflare Tunnel → Coolify → Next.js Web + Hono API + Monitoring
   ├─ Edge rules
   │  ├─ cache-rules.tf (TTL/Bypass/Respect origin, R2 1y)
   │  ├─ redirects.tf (www → apex)
   │  ├─ managed-transforms.tf (headers)
   │  └─ rate-limiting.tf (zone rate limit)
   └─ Worker (cloudflare/worker/): 이미지 CORS 프록시 image.gwak2837.workers.dev

배치 (Cloud Run Jobs) (cloud-run/)
├─ manga-crawl: Cloud Scheduler → Job → Postgres(NEON_DATABASE_URL)
└─ crawl-and-notify: (스케줄러 연결) Job → Postgres(POSTGRES_URL) + Web Push(VAPID)

데이터/캐시
├─ Postgres: POSTGRES_URL (Web/API/notify), NEON_DATABASE_URL (manga-crawl)
└─ Redis: UPSTASH_KV_REST_* (KV), REDIS_URL (Next.js cache 등)
```

## Korean UX Writing

### Use Friendly ~요 Style

- **Use ~해요체 (friendly polite style) instead of ~합니다체 (formal style)** for user-facing text.
- This creates a warmer, more approachable tone while maintaining politeness.

| ❌ ~니다/~습니다 (딱딱함) | ✅ ~요 (친근함)   |
| ------------------------- | ----------------- |
| 로그인이 필요합니다       | 로그인이 필요해요 |
| 저장되었습니다            | 저장됐어요        |
| 삭제에 실패했습니다       | 삭제에 실패했어요 |
| 데이터가 없습니다         | 데이터가 없어요   |
| 적용됩니다                | 적용돼요          |
| 새 탭에서 열립니다        | 새 탭에서 열려요  |
| 확인해주세요              | 확인해 주세요     |

## Code Style

### React (Effects & React Compiler)

- **Avoid unnecessary `useEffect`.** If you can compute something from props/state, compute it during render (don’t store redundant state + update it in an Effect). This avoids extra render passes and desync bugs. See: [React — You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect).
- **Put “user event” side effects in event handlers (or the setter that the event calls)**, not in Effects. Effects are best for “component is shown → sync with external system”.
- **Use Effects only to synchronize with external systems**, e.g.:
  - browser APIs (`localStorage`, `indexedDB`, `BroadcastChannel`, `navigator.*`)
  - timers (`setInterval`, `requestIdleCallback`)
  - subscriptions (`addEventListener`)
  - network / WebSocket / workers / WebLLM engines
- **React Compiler is enabled**: don’t add `useMemo`/`useCallback` by default.
  - Prefer simple code first; add memoization only if it’s actually expensive, or when you need referential stability for an external library.
  - React Compiler can often memoize expensive calculations for you, reducing the need for manual `useMemo`. See: [React — You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect).
- **Don’t store functions in state** (it complicates updates and dependencies). Return callbacks from hooks/components.

### TypeScript

- **Never use `any` type.** Use `unknown` and narrow the type, or define proper interfaces/types.
- Prefer type inference where possible
- Use strict TypeScript configuration.
- Please trust server response type, don't guard type too much

```typescript
// ❌ Bad
function process(data: any) {
  return data.value
}

// ✅ Good
interface Data {
  value: string
}

function process(data: Data) {
  return data.value
}

// ⚠️ Also good, but don't use for our server response.
function process(data: unknown) {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return String((data as { value: unknown }).value)
  }
  throw new Error('Invalid data')
}
```

### Time Calculations

- **Use `ms()` or `sec()` functions for time calculations.** Never use magic numbers for time values.
- `ms()` returns milliseconds, `sec()` returns seconds. Both accept human-readable strings like `'1 hour'`, `'30 minutes'`, `'7 days'`.

```typescript
// ❌ Bad - magic numbers for time
const TOKEN_EXPIRY = 3600000 // What is this? 1 hour in ms
const SESSION_TIMEOUT = 1800 // 30 minutes in seconds?
const LOCK_DURATION = 900000 // Hard to understand

// ✅ Good - use ms() for milliseconds
import ms from 'ms'

const TOKEN_EXPIRY = ms('1 hour')
const COOKIE_MAX_AGE = ms('7 days')
const RATE_LIMIT_WINDOW = ms('15 minutes')

// ✅ Good - use sec() for seconds
import { sec } from '@/utils/sec'

const SESSION_TIMEOUT = sec('30 minutes')
const LOCK_DURATION = sec('15 minutes')
const MFA_CODE_EXPIRY = sec('5 minutes')
```

### File Structure

- **Do not create barrel files (index.ts that re-exports).** Import directly from the source file.

```typescript
// ❌ Bad - barrel file
// src/components/index.ts
export * from './Button'
export * from './Input'
export * from './Modal'

// ❌ Bad - importing from barrel
import { Button, Input } from '@/components'

// ✅ Good - direct imports
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
```

### Database & Migrations

- **Use `drizzle-kit push` as the primary workflow** (via `bun run db:push:*`) to sync schema to DB.
- Drizzle schema files are organized by domain under `src/db/schema/*` and referenced explicitly from `drizzle.config.ts`.

#### Drizzle (Postgres / Supabase) Rules

- **Push-first (including production)**:
  - Never run a production push unless the user explicitly asks for it (high blast radius).
  - Before pushing, ensure the target DB is correct (dev vs prod env vars) and push to staging first when available.

- **Do not commit generated drizzle output**:
  - Keep generated outputs (e.g. `drizzle/**`) out of git.
  - Schema changes are reviewed via the schema code changes (not generated migration artifacts).

- **Naming conventions**:
  - DB table/column names: **snake_case**.
  - TypeScript property keys: **camelCase** (e.g. `createdAt: timestamp('created_at', ...)`).

- **Primary keys (identity)**:
  - Use identity PKs: `.primaryKey().generatedByDefaultAsIdentity()`.
  - IDs are generated by the DB (no app-generated IDs for Postgres identity tables).

- **Timestamps**:
  - Use `timestamp('...', { precision: 3, withTimezone: true })`.
  - Prefer `created_at` + `updated_at` columns.

- **RLS (Supabase)**:
  - All Supabase tables must call `.enableRLS()`.
  - Never disable RLS unless the user explicitly approves and the reason is documented.

- **Constraints & indexes (DB-level enforcement)**:
  - Prefer DB-enforced constraints: `notNull`, `unique`, `references` (FK), `check`.
  - Add indexes intentionally:
    - Index FK columns used in joins/filters.
    - Index columns used in frequent `where` predicates and order-by columns.

- **Query conventions (readability + performance)**:
  - Default to selecting only what you need:
    - ✅ `.select({ id: table.id, createdAt: table.createdAt })`
    - ⚠️ `.select()` is allowed only when selecting the full row is intentional (add a short comment).
  - Prefer explicit `join` (`innerJoin`, `leftJoin`) over relation sugar when the join logic matters.

- **Raw SQL policy (strict)**:
  - ✅ Allowed: `sql\`\`` fragments for expressions/CASE/updates when needed.
  - ✅ Allowed: `sql.identifier(...)` for dynamic identifiers.
  - ❌ Forbidden: `sql.raw(...)` and building SQL via string concatenation.

```ts
// ✅ Good: safe excluded-column reference without sql.raw
import { sql } from 'drizzle-orm'

const excludedToken = sql`excluded.${sql.identifier('token')}`
```

- **bigint mapping guidance**:
  - Prefer `bigint({ mode: 'number' })` for identity IDs and values that will never exceed `Number.MAX_SAFE_INTEGER`.
  - If a column may exceed `Number.MAX_SAFE_INTEGER`, use `bigint({ mode: 'bigint' })` and serialize it as a string at API boundaries.

### Colocation

- **Keep non-reusable logic close to where it's used.** Types, utilities, and constants used only in a specific component or page should be defined in that file or the same folder.

```typescript
// ❌ Bad - separating non-reusable types into a separate file
// src/types/order-form.ts
export interface OrderFormData {
  productId: string
  quantity: number
}

// src/app/orders/page.tsx
import { OrderFormData } from '@/types/order-form'

// ✅ Good - define types used only in this page within the same file
// src/app/orders/page.tsx
interface OrderFormData {
  productId: string
  quantity: number
}

export default function OrdersPage() {
  // ...
}
```

```typescript
// ❌ Bad - separating single-use utilities into lib folder
// src/lib/utils/format-order-id.ts
export function formatOrderId(id: string) {
  return `ORD-${id.toUpperCase()}`
}

// ✅ Good - define within the component file
// src/components/orders/order-table.tsx
function formatOrderId(id: string) {
  return `ORD-${id.toUpperCase()}`
}

export function OrderTable() {
  // uses formatOrderId
}
```

- Only move to shared folders (`lib/`, `utils/`, `types/`) when reused across multiple files.

## HTML/CSS Patterns

### Prefer HTML over JavaScript

Use native HTML features instead of JavaScript where possible. HTML handles validation, form submission, and accessibility better than custom JS implementations.

### HTML Validation

- **Use HTML `required` attribute** instead of JS validation for empty checks.
- Let browser handle basic validation, use JS only for complex rules.

```tsx
// ❌ Bad - JS validation for empty check
<Button disabled={!name || !email || isSaving} onClick={handleSave}>
  저장
</Button>

// ✅ Good - HTML required + form submission
<form onSubmit={handleSave}>
  <Input name="name" required />
  <Input name="email" type="email" required />
  <Button type="submit" disabled={isSaving}>저장</Button>
</form>
```

### Conditional Styling with Attributes

- **Use `aria-*` or `data-*` attributes with Tailwind variants** instead of conditional className.
- This provides cleaner code and better accessibility.
- Use `aria-disabled`, `aria-selected`, `aria-checked`, `data-state`, etc.

```tsx
// ❌ Bad - Conditional className with template literals
<div className={`card ${!enabled ? 'opacity-50' : ''}`}>

<div className={`item ${isActive ? 'bg-blue-500 text-white' : 'bg-gray-100 text-gray-600'}`}>

// ✅ Good - aria/data attributes with Tailwind variants
<div aria-disabled={!enabled} className="card aria-disabled:opacity-50">

<div aria-selected={isActive} className="item aria-selected:bg-blue-500 aria-selected:text-white bg-gray-100 text-gray-600">

<div data-state={status} className="item data-[state=active]:bg-blue-500 data-[state=pending]:bg-yellow-500">
```

### HTML id/name Naming

- **Use kebab-case for HTML `id` and `name` attributes** instead of camelCase.
- This includes FormData keys since they derive from `name` attributes.

```tsx
// ❌ Bad - camelCase
<Label htmlFor="userName">이름</Label>
<Input id="userName" name="userName" />
formData.append('mallId', value)

// ✅ Good - kebab-case
<Label htmlFor="user-name">이름</Label>
<Input id="user-name" name="user-name" />
formData.append('mall-id', value)
```

### Avoid Wrapper Functions

- **Call props directly** instead of creating pass-through wrapper functions.

```tsx
// ❌ Bad - Unnecessary wrapper function
function handleDelete(id: string) {
  onDelete(id)
}

<button onClick={() => handleDelete(item.id)}>삭제</button>

// ✅ Good - Direct prop call
<button onClick={() => onDelete(item.id)}>삭제</button>
```

### Expandable/Collapsible UI

- **Use `<details>` and `<summary>`** instead of JavaScript state for toggle/accordion UI.
- Browser handles open/close natively with built-in accessibility.
- Use `group` and `group-open:` for styling and animations.

```tsx
// ❌ Bad - JavaScript state for toggle
const [isOpen, setIsOpen] = useState(false)

<div>
  <button onClick={() => setIsOpen(!isOpen)}>
    {isOpen ? <ChevronDown /> : <ChevronRight />}
    Toggle
  </button>
  {isOpen && <div>Content</div>}
</div>

// ✅ Good - Native HTML details/summary
<details className="group">
  <summary className="cursor-pointer list-none [&::-webkit-details-marker]:hidden">
    <ChevronRight className="transition-transform group-open:rotate-90" />
    Toggle
  </summary>
  <div>Content</div>
</details>
```

## Dialog (Modal) Pattern

All modals must use the native `<dialog>`-based `Dialog` component and the standard composition components.

### Standard Composition

- **Always use**: `Dialog` + `DialogHeader` + `DialogBody` (+ `DialogFooter` when there are actions)
- **Accessibility**: `Dialog` requires `ariaLabel` (no exceptions)
- **Close button**: always render via `DialogHeader` (title is optional)

### Standard Recipe (no form)

```tsx
<Dialog ariaLabel="공유하기" open={isOpen} onClose={close}>
  <DialogHeader title="공유하기" onClose={close} />
  <DialogBody>{/* scrollable content */}</DialogBody>
  <DialogFooter className="flex gap-2">
    <button type="button" onClick={close}>
      취소
    </button>
    <button type="button">확인</button>
  </DialogFooter>
</Dialog>
```

### Form Recipe

When you need submit semantics, make the `<form>` the direct child of `Dialog`.

```tsx
<Dialog ariaLabel="서재 만들기" open={open} onClose={onClose}>
  <form className="flex flex-1 flex-col min-h-0" onSubmit={handleSubmit}>
    <DialogHeader title="서재 만들기" onClose={onClose} />
    <DialogBody>{/* inputs */}</DialogBody>
    <DialogFooter className="flex gap-2">
      <button type="button" onClick={onClose}>
        취소
      </button>
      <button type="submit">저장</button>
    </DialogFooter>
  </form>
</Dialog>
```

## Security

### Rate Limiting

- **IP-based rate limiting is managed at the infrastructure level** (e.g., CDN, load balancer, reverse proxy).
- Do NOT implement IP-based rate limiting in application code.
- For user-specific rate limiting (e.g., login attempts), use email/account-based tracking instead of IP.
